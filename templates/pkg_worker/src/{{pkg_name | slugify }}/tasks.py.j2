"""Worker tasks."""

import time
from datetime import UTC, datetime, timedelta
from typing import Any

from celery import Task
from celery.utils.log import get_task_logger

from {{ pkg_name | slugify }}.worker import celery_app

logger = get_task_logger(__name__)


@celery_app.task(name="{{ pkg_name }}.tasks.health_check")
def health_check() -> dict[str, str]:
    """Health check task to verify worker is running."""
    logger.info("Worker health check - OK")
    return {"status": "healthy", "timestamp": datetime.now(UTC).isoformat()}


@celery_app.task(name="{{ pkg_name }}.tasks.cleanup_old_data")
def cleanup_old_data() -> dict[str, str]:
    """Clean up old data periodically."""
    logger.info("Starting cleanup of old data")
    # Add your cleanup logic here
    cutoff_date = datetime.utcnow() - timedelta(days=30)
    logger.info(f"Cleaning up data older than {cutoff_date}")
    # Simulate cleanup
    time.sleep(2)
    logger.info("Cleanup completed")
    return {"status": "completed", "cutoff_date": cutoff_date.isoformat()}


@celery_app.task(bind=True, max_retries=3, name="{{ pkg_name }}.tasks.process_item")
def process_item(self: Task, item_id: int, item_data: dict) -> dict[str, Any]:
    """Process an item asynchronously.

    Args:
        self: The bound task instance used for retry logic and task context.
        item_id: The ID of the item to process
        item_data: The data associated with the item
    """
    try:
        logger.info(f"Processing item {item_id}", extra={"item_data": item_data})

        # Simulate processing
        time.sleep(5)

        # Add your processing logic here
        result = {
            "item_id": item_id,
            "status": "processed",
            "processed_at": datetime.now(UTC).isoformat(),
        }

        logger.info(f"Item {item_id} processed successfully", extra={"result": result})
        return result

    except Exception as exc:
        logger.error(f"Error processing item {item_id}: {exc}")
        # Retry with exponential backoff
        raise self.retry(exc=exc, countdown=60 * (2 ** self.request.retries)) from exc


@celery_app.task(bind=True, max_retries=5, name="{{ pkg_name }}.tasks.send_notification")
def send_notification(self: Task, recipient: str, message: str, channel: str = "email") -> dict[str, str]:
    """Send a notification to a recipient.

    Args:
        self: The bound task instance used for retry logic and task context.
        recipient: The recipient identifier
        message: The message to send
        channel: The notification channel (email, sms, push)
    """
    try:
        logger.info(f"Sending {channel} notification to {recipient}")

        # Add your notification logic here based on channel
        if channel == "email":
            # Send email
            pass
        elif channel == "sms":
            # Send SMS
            pass
        elif channel == "push":
            # Send push notification
            pass

        # Simulate sending
        time.sleep(2)

        result = {
            "recipient": recipient,
            "channel": channel,
            "status": "sent",
            "sent_at": datetime.now(UTC).isoformat(),
        }

        logger.info("Notification sent successfully", extra={"result": result})
        return result

    except Exception as exc:
        logger.error(f"Error sending notification: {exc}")
        raise self.retry(exc=exc, countdown=30 * (2 ** self.request.retries)) from exc


@celery_app.task(name="{{ pkg_name }}.tasks.batch_process")
def batch_process(items: list[dict]) -> dict[str, Any]:
    """Process multiple items in batch.

    Args:
        items: List of items to process
    """
    logger.info(f"Starting batch processing of {len(items)} items")

    results = []
    for item in items:
        # Process each item
        result = process_item.apply_async(
            args=[item["id"], item],
            queue="default",
        )
        results.append(result.id)

    logger.info(f"Batch processing initiated, task IDs: {results}")
    return {"task_ids": results, "total": len(items)}
